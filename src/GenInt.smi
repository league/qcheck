_require "basis.smi"
_require "GEN_TYPES.sml"
_require "PREGEN_SIG.sml"
_require "PRETEXT_GENERATOR.sml"
_require "TEXT_GENERATOR.sml"
_require "INT_GENERATOR.sml"

functor GenInt
  (S : sig
    (* GEN_TYPES *)
    type rand
    type 'a gen = rand -> 'a * rand
    type ('a,'b) co = 'a -> 'b gen -> 'b gen
    (* PREGEN_SIG *)
    val new : unit -> rand
    val range : int * int -> rand -> int * rand
    type ('a,'b) reader = 'b -> ('a * 'b) option
    val lift : 'a -> 'a gen
    val select : 'a vector -> 'a gen
    val choose : 'a gen vector -> 'a gen
    val choose' : (int * 'a gen) vector -> 'a gen
    val selectL : 'a list -> 'a gen
    val chooseL : 'a gen list -> 'a gen
    val chooseL' : (int * 'a gen) list -> 'a gen
    val filter : ('a -> bool) -> 'a gen -> 'a gen
    val zip : 'a gen * 'b gen -> ('a * 'b) gen
    val zip3 : 'a gen * 'b gen * 'c gen -> ('a * 'b * 'c) gen
    val zip4 : 'a gen * 'b gen * 'c gen * 'd gen -> ('a * 'b * 'c * 'd) gen
    val map : ('a -> 'b) -> 'a gen -> 'b gen
    val map2 : ('a * 'b -> 'c) -> 'a gen * 'b gen -> 'c gen
    val map3 : ('a * 'b * 'c -> 'd) -> 'a gen * 'b gen * 'c gen -> 'd gen
    val map4 : ('a * 'b * 'c * 'd -> 'e) -> 'a gen * 'b gen * 'c gen * 'd gen -> 'e gen
    val flip : bool gen
    val flip' : int * int -> bool gen
    val list : bool gen -> 'a gen -> 'a list gen
    val option : bool gen -> 'a gen -> 'a option gen
    val vector : (int * (int -> 'a) -> 'b) -> int gen * 'a gen -> 'b gen
    val variant : (int,'a) co
    val variant' : (int * int,'a) co
    val arrow : ('a,'b) co * 'b gen -> ('a -> 'b) gen
    val cobool : (bool,'a) co
    val colist : ('a,'b) co -> ('a list,'b) co
    val coopt : ('a,'b) co -> ('a option,'b) co
    type stream
    val start : rand -> stream
    val limit' : int -> 'a gen -> ('a,stream) reader
    val limit : 'a gen -> ('a,stream) reader

    (* TEXT_GENERATOR *)
    type char = char
    type string = string
    type substring = substring

    val char : char gen
    val charRange : char * char -> char gen
    val charFrom : string -> char gen
    val charByType : (char -> bool) -> char gen
    val string : int gen * char gen -> string gen
    val substring : string gen -> substring gen
    val cochar : (char,'a) co
    val costring : (string,'a) co
    val cosubstring : (substring,'a) co

    (* INTEGER *)
    structure Int :
    sig
      type int
      val precision : Int.int option
      val minInt : int option
      val maxInt : int option
      val toLarge : int -> IntInf.int
      val fromLarge : IntInf.int -> int
      val toInt : int -> Int.int
      val fromInt : Int.int -> int
      val ~ : int -> int
      val + : int * int -> int
      val - : int * int -> int
      val * : int * int -> int
      val div : int * int -> int
      val mod : int * int -> int
      val quot : int * int -> int
      val rem : int * int -> int
      val min : int * int -> int
      val max : int * int -> int
      val abs : int -> int
      val sign : int -> Int.int
      val sameSign : int * int -> bool
      val > : int * int -> bool
      val >= : int * int -> bool
      val < : int * int -> bool
      val <= : int * int -> bool
      val compare : int * int -> order
      val toString : int -> string
      val fromString : string -> int option
      val scan : StringCvt.radix -> (char,'a) StringCvt.reader -> (int,'a) StringCvt.reader
      val fmt : StringCvt.radix -> int -> string
    end
  end) =
struct
  type rand = S.rand
  type 'a gen = 'a S.gen
  type ('a,'b) co = ('a,'b) S.co
  type int = S.Int.int
  val pos : int gen
  val neg : int gen
  val nonpos : int gen
  val nonneg : int gen
  val int : int gen
  val coint : (int,'a) co
end

